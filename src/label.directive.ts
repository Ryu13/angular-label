import { Directive, Input, ElementRef, OnInit, OnDestroy } from '@angular/core';


const DEFAULT_WRAPPER_ELEM = 'div';

@Directive({
  selector: '[aLNgLabel]'
})
export class LabelDirective implements OnInit, OnDestroy {

  @Input()
  type: string;

  @Input()
  id: string;

  @Input()
  cmLabel: string;

  @Input('label-wrapper')
  labelWrapper: string;

  @Input('label-top')
  labelTop: string;

  @Input('label-top-small')
  labelTopSmall: string;

  @Input('label-right')
  labelRight: string;

  @Input()
  labelStyle: string;

  @Input()
  customLabelClass: string = '';

  @Input()
  wrapperClass: string = '';

  @Input('label-wrapper-styles')
  labelWrapperStyles: string;

  /*
    Mechanism to allow rendering after the parent has finished to ensure a parent has been properly rendered.
    This is used since angular renders child-deep. When this directive is used in a content-projection manner (ng-content),
    child is rendered without the proper parent structure. Defer will tell this directive to async try to render (setTimeout 0).
  */
  @Input()
  defer: boolean = false;

  private wrapper: any;

  constructor(private el: ElementRef) { }

  ngOnInit() {
    if (this.defer) {
      setTimeout(() => this.initialize());
    } else {
      this.initialize();
    }
  }
  
  initialize() {
    const el = this.el;
    el.nativeElement.setAttribute('id', this.id);
    const parent = el.nativeElement.parentNode;
    const isCheckbox = LabelDirective.isCheckbox(el.nativeElement);
  
    if (this.labelWrapper != null || isCheckbox) {
      this.wrapElement(el);
    } else { // Needs another look, but label right without label wrapper is almost always a bad idea so for now we assume label-wrapper is intended
      // assumption above only made for isCheckbox since that subtley forces label-right
      if ((LabelDirective.isCheckbox(el.nativeElement) || this.labelRight != null) && this.labelTop == null && this.labelTopSmall == null) {
        parent.insertBefore(this.genLabelElement(), null);
      } else {
        parent.insertBefore(this.genLabelElement(), el.nativeElement);
      }
    }
  }

  wrapElement(el: ElementRef) {
    const native = el.nativeElement;
    // generate wrapping element
    const wrapperElemStr = this.labelWrapper || DEFAULT_WRAPPER_ELEM;
    const wrapperElem = document.createElement(wrapperElemStr);
    this.wrapper = wrapperElem;
    
    wrapperElem.setAttribute('style', this.labelWrapperStyles);

    // copy over any attribute values that are generated by angular
    // to handle component dom nesting
    const attrs = native.attributes;
    // loop this way instead of (of) etc. to avoid hitting attribute values themselves
    for (let i = 0; i < attrs.length; i++) {
      const attr = attrs[i].name;
      if (attr.includes('label') || ['id'].includes(attr)) {
        continue;
      }
      wrapperElem.setAttribute(attr, native.getAttribute(attr));
    }
    wrapperElem.classList.add(...['label-wrapper', ...this.wrapperClass.split(' ')].filter(c => c));

    // replace the element with the wrapper element here first
    native.replaceWith(wrapperElem);

    if ((LabelDirective.isCheckbox(native) || this.labelRight != null) && this.labelTop == null && this.labelTopSmall == null) {
      wrapperElem.insertBefore(native, null);
      wrapperElem.insertBefore(this.genLabelElement(), null);
    } else { // assumes labelleft
      // update the wrapper element to add in the label and then the orphaned child
      wrapperElem.insertBefore(this.genLabelElement(), null);
      wrapperElem.insertBefore(native, null);
    }

    return wrapperElem;
  }

  genLabelElement() {
    const elemStr = 'label';
    const labelElem = document.createElement(elemStr);
    const labelClass = (
      this.customLabelClass 
        + (this.labelTop != null ? ' label-top' : '')
        + (this.labelTopSmall != null ? ' label-top-small': '')
    ).trim();
    labelElem.setAttribute('for', this.id);
    labelElem.setAttribute('class', labelClass);
    labelElem.setAttribute('style', this.labelStyle || '');
    const innerHTML = this.el.nativeElement.required ? 
      `${this.cmLabel} <span class="red">*</span>`
      : this.cmLabel
    ;
    labelElem.innerHTML = innerHTML;
    return labelElem;
  }

  ngOnDestroy() {
    this.wrapper && this.wrapper.remove();
  }

  static isCheckbox(nativeElement) : boolean {
    const elementType = nativeElement.attributes.type;
    return elementType ? elementType.value === 'checkbox' : false;
  }
}
